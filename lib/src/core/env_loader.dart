import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'environment_manager.dart';

/// Utility class for loading environment configurations from .env files
class EnvLoader {
  /// Load environments from .env files in the project root
  /// 
  /// Supports:
  /// - .env (default environment)
  /// - .env.dev or .env.development
  /// - .env.prod or .env.production
  /// - .env.test
  /// - .env.staging
  /// - .env.local (for local overrides, should be in .gitignore)
  /// 
  /// Returns null if no .env files are found
  static Future<List<EnvironmentConfig>?> loadFromEnvFiles() async {
    final environments = <EnvironmentConfig>[];
    
    // Define environment file mappings
    final envFiles = {
      'Default': '.env',
      'Development': ['.env.dev', '.env.development'],
      'Production': ['.env.prod', '.env.production'],
      'Test': ['.env.test'],
      'Staging': ['.env.staging'],
      'Local': ['.env.local'],
    };
    
    for (final entry in envFiles.entries) {
      final envName = entry.key;
      final files = entry.value is String ? [entry.value as String] : entry.value as List<String>;
      
      for (final fileName in files) {
        try {
          // Try to load the file
          final loaded = await _loadEnvFile(fileName);
          if (loaded != null) {
            environments.add(
              EnvironmentConfig(
                name: envName,
                variables: loaded,
                isDefault: envName == 'Default' || envName == 'Development',
              ),
            );
            break; // Use the first file that exists for this environment
          }
        } catch (e) {
          debugPrint('Failed to load $fileName: $e');
        }
      }
    }
    
    // Also check for custom environment files with pattern .env.*
    await _loadCustomEnvFiles(environments);
    
    return environments.isEmpty ? null : environments;
  }
  
  /// Load a specific .env file
  static Future<Map<String, dynamic>?> _loadEnvFile(String fileName) async {
    try {
      // Check if running in Flutter app context
      if (!kIsWeb) {
        // Try to load from file system (for development)
        final file = File(fileName);
        if (await file.exists()) {
          await dotenv.load(fileName: fileName);
          return Map<String, dynamic>.from(dotenv.env);
        }
      }
      
      // Try to load from assets (for production builds)
      try {
        await dotenv.load(fileName: fileName);
        return Map<String, dynamic>.from(dotenv.env);
      } catch (e) {
        // File doesn't exist in assets
        return null;
      }
    } catch (e) {
      debugPrint('Error loading $fileName: $e');
      return null;
    }
  }
  
  /// Discover and load custom .env.* files
  static Future<void> _loadCustomEnvFiles(List<EnvironmentConfig> environments) async {
    // This is tricky because we can't list files in assets
    // So we'll try common patterns
    final customPatterns = [
      '.env.qa',
      '.env.uat',
      '.env.demo',
      '.env.sandbox',
    ];
    
    for (final pattern in customPatterns) {
      try {
        final loaded = await _loadEnvFile(pattern);
        if (loaded != null) {
          // Extract environment name from file name
          final envName = _extractEnvName(pattern);
          
          // Check if this environment already exists
          if (!environments.any((e) => e.name == envName)) {
            environments.add(
              EnvironmentConfig(
                name: envName,
                variables: loaded,
              ),
            );
          }
        }
      } catch (e) {
        // Ignore, file doesn't exist
      }
    }
  }
  
  /// Extract environment name from file name
  static String _extractEnvName(String fileName) {
    // .env.production -> Production
    // .env.dev -> Dev
    // .env -> Default
    if (fileName == '.env') {
      return 'Default';
    }
    
    final parts = fileName.split('.');
    if (parts.length > 2) {
      final envPart = parts.last;
      // Capitalize first letter
      return envPart[0].toUpperCase() + envPart.substring(1).toLowerCase();
    }
    
    return 'Unknown';
  }
  
  /// Create a sample .env file content
  static String generateSampleEnvFile({String environment = 'development'}) {
    return '''
# Environment: $environment
# Generated by Flutter Dev Panel

# API Configuration
API_URL=https://api.example.com
API_KEY=your_api_key_here
API_TIMEOUT=30000

# WebSocket Configuration  
SOCKET_URL=wss://socket.example.com
SOCKET_RECONNECT_INTERVAL=5000

# Feature Flags
DEBUG=true
ENABLE_LOGGING=true
ENABLE_CRASH_REPORTING=false

# App Configuration
APP_NAME=Flutter Dev Panel
APP_VERSION=1.0.0
BUILD_NUMBER=1

# Third-party Services
SENTRY_DSN=
FIREBASE_PROJECT_ID=
ANALYTICS_ID=

# Other Settings
MAX_CACHE_SIZE=104857600
SESSION_TIMEOUT=1800
DEFAULT_LANGUAGE=en
''';
  }
  
  /// Merge environments from different sources
  /// Priority: .env files > code configuration > saved configuration
  static List<EnvironmentConfig> mergeEnvironments({
    List<EnvironmentConfig>? fromEnvFiles,
    List<EnvironmentConfig>? fromCode,
    List<EnvironmentConfig>? fromStorage,
  }) {
    final merged = <String, EnvironmentConfig>{};
    
    // Start with saved configuration (lowest priority)
    if (fromStorage != null) {
      for (final env in fromStorage) {
        merged[env.name] = env;
      }
    }
    
    // Override with code configuration
    if (fromCode != null) {
      for (final env in fromCode) {
        merged[env.name] = env;
      }
    }
    
    // Override with .env files (highest priority)
    if (fromEnvFiles != null) {
      for (final env in fromEnvFiles) {
        // Merge variables if environment already exists
        if (merged.containsKey(env.name)) {
          final existing = merged[env.name]!;
          final mergedVars = {...existing.variables, ...env.variables};
          merged[env.name] = existing.copyWith(variables: mergedVars);
        } else {
          merged[env.name] = env;
        }
      }
    }
    
    return merged.values.toList();
  }
  
  /// Validate environment configuration
  static bool validateEnvironment(EnvironmentConfig env) {
    // Check for required variables
    final requiredVars = ['API_URL']; // Add more as needed
    
    for (final varName in requiredVars) {
      if (!env.variables.containsKey(varName) || 
          env.variables[varName] == null ||
          env.variables[varName].toString().isEmpty) {
        debugPrint('Environment ${env.name} missing required variable: $varName');
        return false;
      }
    }
    
    return true;
  }
}